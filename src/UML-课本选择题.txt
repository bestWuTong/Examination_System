模型是（）。
A) 现实世界的简化
B) 现实世界的图形化描述
C) 现实世界的具体化描述
D) 现实世界的封装
△A△

下列关于UML的论述，错误的是（）。
A) UML将几个面向对象方法统一起来
B) UML可作为与软件开发人员之间的通用语言
C) UML可作为一种指导软件开发的通用过程
D) UML可用于通用领域，也可用于嵌入式领域
△C△

UML中的“统一”体现在很多方面，下列选项（）不是UML统一的内容。
A) 开发生命周期
B) 软件开发过程
C) 应用领域
D) 实现语言和平台
△D△

和 UML 1.x 相比，UML 2进行了比较大的改动，对于普通用户来说，主要的改动体现在对一些图进行了调整。下列4个选项中，（）是UML 2新增的用于描述静态结构的图。
A) 类图
B) 交互概览图
C) 时间图
D) 组合结构图
△D△

下列有关业务建模的概念和方法的论述中，错误的是（）。
A) 业务建模是软件开发的必备环节
B) 可以采用用例技术进行业务建模
C) 可以通过活动图详细描述业务流程
D) 业务模型可以映射到系统模型
△A△

下列有关业务模型的相关概念中，错误的是（）。
A) 业务参与者在业务之外
B) 业务工人在业务内部
C) 业务用例为业务工人提供价值
D) 业务实体在业务内部
△C△

下列关于活动图的论述中，错误的是（）。
A) 可以包括多个起点
B) 分区用来表示该分区内的活动是由谁负责的
C) 活动可以简单，可以复杂
D) 可以使用活动图描述业务用例流程
△A△

下列选项中，（）不会出现在活动图中。
A) 活动
B) 用例
C) 对象
D) 分叉
△B△

业务模型中的业务实体，在系统模型中最有可能成为（）。
A) 系统用例
B) 参与者
C) 控制类
D) 实体类
△D△

以某海鲜酒家为研究对象，下列选项中，（）是业务工人。
A) 服务员
B) 菜单实体
C) 食客
D) 菜
△A△

以某医院为研究对象，下列业务用例图中，正确的是（）。
A) 医生 (圆圈+箭头) —— 治病 (椭圆)
B) 病人 —— 看病 (椭圆)
C) 医生 —— 治病 (椭圆)
D) 病人 —— 吃药 (椭圆)
△B△

下列选项中，（）是顺序图具备而通信图不具备的功能。
A) 描述对象间消息传递的顺序
B) 显示交互对象间的关系
C) 显示交互时对象的执行发生
D) 描述用例实现的交互场景
△C△

下列选项中，（）是通信图具备而顺序图不具备的功能。
A) 描述对象间消息传递的顺序
B) 显示交互对象间的关系
C) 显示交互时对象的执行发生
D) 描述用例实现的交互场景
△B△

面向对象的设计原则是指导我们进行面向对象设计的基本思想，如果违背了这些原则，则设计模型可能会存在很严重的问题；现发现在一个已有的设计模型中，有一些使用父类正常运行的方法，在使用子类时无法运行，这种现象可能是因为我们违背了（）设计原则。
A) LSP
B) OCP
C) SRP
D) DIP
△A△

面向对象的设计原则与设计模式最本质的区别是（）。
A) 设计原则用于构架设计，而设计模式用于构件设计
B) 设计原则是基本指导思想，而模式则是具体技术的应用
C) 设计原则与编程语言无关，而设计模式依赖于特定的编程语言
D) 设计原则适用于所有的面向对象系统，而设计模式只适用于特定的应用系统
△B△

下列有关设计原则和设计模式的论述中，错误的是（）。
A) 设计原则是构造高质量设计的出发点
B) 设计模式是遵循设计原则的手段之一
C) 设计原则来自于设计模式的具体应用
D) 设计模式的核心思想是多态包容
△C△

设计模式是设计中通用问题的解决方案；GoF的23种设计模式为我们的设计提供了许多优秀的解决方案。在某一系统的设计过程中发现这样一个问题：已有的两个设计类需要互相通信，但接口不一致，此时我们应该考虑使用（）来解决。
A) 状态(State)模式
B) 装饰(Decorator)模式
C) 适配器(Adapter)模式
D) 命令(Command)模式
△C△

迪米特(Demeter)准则用于指导详细设计阶段类的职责分配，根据该准则，在一个对象的方法中，其消息不应该发往（）。
A) 对象本身
B) 该方法的参数
C) 该方法内创建的对象
D) 直接依赖于该对象的对象
△D△

下列有关需求、分析和设计这3个概念的论述中，错误的是（）。
A) 需求是从用户视角描述用户问题
B) 分析是从开发团队视角描述用户问题
C) 设计是从开发团队视角解决用户问题
D) 需求在问题域，分析和设计则都在技术域
△D△

下列有关 UML 包图的论述中正确的是（）。
A) 类才可以被包含在包中
B) 包中不能包含其他包
C) 包之间存在泛化关系
D) 可以通过添加构造型将包表示为子系统
△C△

下列选项中，（）不是设计元素。
A) 实体类
B) 设计类
C) 子系统
D) 接口/主动类
△A△

下列有关接口和实现关系的论述中，错误的是（）。
A) 接口是操作的集合
B) 接口主要用于支持代码的复用
C) 可以利用具体类来实现接口
D) 可以利用子系统来实现接口
△B△

关于泛化关系和实现关系的区别，下列论述错误的是（）。
A) 实现关系容易支持多态性，而泛化关系则很难支持多态性
B) 泛化关系是类与类之间的关系，而实现关系则是设计元素与接口之间的关系
C) 泛化关系可以用于重用实现，而实现关系只能重用行为的规约
D) 泛化关系中父类可以提供缺省实现，而实现关系中接口不提供任何实现
△A△

与包相比，子系统具有更丰富的语义，它能够通过接口对外提供行为。下列4个选项中，（）是包和子系统都具有的特点。
A) 一种分组机制
B) 对外提供行为
C) 完全封装实现细节
D) 容易被替换
△A△

在设计阶段的用例实现过程中，封装子系统交互带来的好处不包括（）。
A) 简化交互图，减少混乱
B) 支持并行开发
C) 容易变更和替换
D) 降低开发成本
△D△

子系统的职责是指（）。
A) 子系统内部元素的所有操作集合
B) 子系统接口的操作集合
C) 子系统代理类的操作集合
D) 不能直接建模，需要单独描述
△B△

关于接口和子系统的关系，下列说法错误的是（）。
A) 子系统可以实现接口所描述的行为
B) 相同的接口可以有多个不同的子系统来实现
C) 一个子系统可以实现多个不同的接口
D) 实现相同接口的不同子系统，其对外体现的行为不一定相同
△D△

有关构架机制的概念，下列说法错误的是（）。
A) 构架机制一般关注系统的非功能需求
B) 构架机制可分为分析机制、设计机制和实现机制
C) 机制是运用特定的实现技术来编码实现相应的分析机制
D) 设计模式也是一种设计机制
△C△

有关进程建模的概念，下列说法错误的是（）。
A) 所有的系统都必须进行进程建模
B) 可使用类图进行进程建模
C) 进程和进程之间可以定义依赖关系
D) 进程和线程之间可以定义组合关系
△A△

已知类 A有到类B的关联关系，类A运行于进程 processA中，而类B运行于进程 processB中，则进程 processA 和进程 processB之间应该存在（）。
A) 依赖
B) 关联
C) 组合
D) 条件不足，无法确定
△A△

关于部署图，下面说法正确的是（）。
A) 任何系统都需要进行部署视图建模
B) 部署图可用来描述目标程序结构和关系
C) 部署图可用来描述系统的硬件结构
D) 部署图和构件图同构，只是表现方式不同
△C△

在进行系统构架设计时，一个最重要的原则就是避免包之间的循环依赖。下列4个选项中，（）构架包图不存在循环依赖。
A) A - B  (箭头循环)
B) A - A' - B  (箭头不循环)
C) A - B - C  (箭头循环)
D) A - A' - B - C  (箭头循环)
△B△

现要将下面的类图分割成3个包，下列选项中最合适的两个分解点是（）。
（注：此处为一张包含类A-I及相关关系的类图）
（ABCD）- - - >d （EF）——>f（GHI）
A) (a)和(d)
B) (b)和(d)
C) (d)和(f)
D) (d)和(h)
△C△

下图展示了两个接口IPay和ICheck 及相关子系统 CreditSys 和 CheckSys 的静态结构。根据该图，完成下列第(1)~(2)题。
（图略）

(1) 对于外界来说，上图中两个子系统所表现出来的职责（）。
A) 完全相同
B) 不同，CreditSys比CheckSys 多
C) 不同，CheckSys比CreditSys多
D) 无法确定，因为子系统内部实现细节未知

(2) 某一外部类C，需访问上图中CheckSys子系统内 Auth类的 verify()操作，则最佳访问方式是（）。
A) 直接通过Auth 类访问
B) 通过接口 IPay 访问
C) 通过接口 ICheck 访问
D) Auth 封装在子系统内部，其操作目前无法访问

△CD△

在分析阶段，建立了类A到类B的单向关联；在用例设计过程中，出于其他原因，将类A封装到子系统S1中，而将类B封装到子系统S2中，此时子系统S1和S2之间（）。
A) 建立从子系统S1到S2的依赖关系
B) 建立从子系统S1到S2的关联关系
C) 建立从子系统 S1 到S2 的接口之间的依赖关系
D) 建立从子系统S1到S2的接口之间的关联关系
△C△

在进行类设计时，类之间共有5种关系，它们之间的耦合度也各不相同。下列4个选项中，（）的耦合度最高。
A) 关联关系
B) 组合关系
C) 泛化关系
D) 依赖关系
△C△

当需要描述一个类的对象跨越多个用例所表现出的不同行为时，应该考虑（）。
A) 对象图
B) 顺序图
C) 状态机图
D) 通信图
△C△

下列类关系中，（）不能在类自身之间建立。
A) 关联关系
B) 依赖关系
C) 聚合关系
D) 组合关系
△B△

已知类A需要类B提供的服务。下列所描述的4种情况中，（）一般不会把类A和类B之间的关系定义成依赖关系。
A) 类A中存在两个操作都需要访问类B的同一个对象
B) 类A的某个操作内部创建了类B的对象，而其他操作均与类B无关
C) 类A的某个操作的参数是类B的对象，而其他操作均与类B无关
D) 类B是一个全局变量
△A△

关于关系数据库和面向对象系统之间的差别，下列论述中错误的是（）。
A) 关系数据库集中在数据上，而面向对象系统则集中在行为上
B) 关系数据库直接对外暴露数据，而面向对象系统则封装数据
C) 面向对象系统比关系数据库更高效
D) 面向对象系统适合处理复杂行为而关系数据库则适合数据报表系统
△C△

数据库设计过程就是将对象模型映射成数据模型，下列4个选项均给出了两个术语，其中前一个为对象模型中的术语，后一个为数据模型中的术语，那么（）术语不是对应的。
A) 类、实体
B) 关联、关系
C) 属性、主键
D) 操作、存储过程
△C△

在下面的状态机图中，描述了两个状态 State1 和 State2 之间的转移，该转移上面所描述的4个选项中，（）代表转移发生时需要满足的条件。

[State1] — A(B)[C]/D —> [State2]
A) A
B) B
C) C
D) D
△C△

下图是某系统用例的早期用例实现(设计)的顺序图。随着设计过程的深入，基于多方面的原因，设计师将类 B、C 封装成了一个子系统 S。在子系统设计阶段，采用顺序图对该子系统的职责 find() 进行详细设计，则下列消息不会出现在该顺序图中(选项中采用的是上图中的消息编号)的是（）。
（图略）

A) 1.1.1
B) 1.1.3.1
C) 1.1.3.1.1
D) 1.3
△D△

下图是类 C的状态模型，其状态的变化主要是受该类的属性 x(整数类型)的影响。当类C的对象 c1 处于 A2 状态时，若x值修改为25，则该对象将转入（）状态。

简略图片：[A1、A2] ——> [B1、B2、B3]

A) A1
B) A2
C) B1
D) 无法确定
△C△

根据下面所示的类图，完成第(1)~(4)题。
（图略）

(1) 上图中订单和订单项之间的关系是（）。
A) 依赖关系
B) 关联关系
C) 聚合关系
D) 组合关系

(2) 上图中订单和商品之间的关系是（）。
A) 依赖关系
B) 关联关系
C) 聚合关系
D) 组合关系

(3) 针对上图中类的关系论述，错误的是（）。
A) 订单项不能脱离订单独立存在
B) 一件商品至少存储在1个仓库中
C) 一个中心仓库可能没有，也可能有多个分仓库
D) 仓库类的自反关联意味着每个仓库对象之间存在着自反链接

(4) 在类设计期间，需要将上图中商品和仓库之间的关联类设计为普通的类，下列设计方案中，正确的是（）。
四个设计方案图 ：
A：商品-01-库存-11-仓库
B：商品-01-库存-01-仓库
C：商品-10-库存-11-仓库
D：商品-11-库存-01-仓库

△DADD△