在C++语言中，数据封装的目的是（）。
A) 数据的规范化
B) 便于数据转换
C) 避免数据丢失
D) 防止不同模块之间数据的非法访问
△D△
C++是（）。
A) 结构化程序设计语言
B) 面向对象程序设计语言
C) 面向服务程序设计语言
D) 面向过程的程序设计语言
△B△
面向对象思想的三大特性不包括（）。
A) Encapsulation
B)Inheritance
C) Polymorphism
D) Template
△D△
面向对象程序设计思想的主要特征中不包括（）。
A) 多态
B) 封装
C) 继承
D) 模块
△D△
类定义的内容允许被其他对象无限制地存取是（）。
A) private 部分
B) protected 部分
C) public 部分
D) 以上都不对
△C△
以下程序段输出结果为（）。
int a = 11;
cout << static_cast<float>(a)/2 << endl;
A) 5.5
B) 5
C) 11
D) 6
△A△
以下程序段的输出结果为（）。
float a = 1.2;
cout << setw(4) << setfill('#') << a << endl;
A) ##1.2
B) 1.2##
C) #1.2
D) 1.2#
△C△
如果使用cout和cin，必须包含的头文件为（）。
A) iostream
B) iomanip
C) string
D) istream
△A△
若定义：string  str;  执行 cin>>str;，设输入：How are you↙，则str的内容是（）。
A) How are you
B) How
C) How are
D) you
△B△
若定义：string  str;  执行 getline(cin, str);，设输入：Microsoft Visual Studio↙，则str的内容是（）。
A) Microsoft Visual Studio
B) Microsoft
C) Microsoft Visual
D) 以上都不对
△A△
如果使用string类型，必须包含的头文件为（）。
A) iostream
B) cstring
C) string
D) string.h
△C△
关于string类型，下列叙述错误的是（）。
A)	string类型可以存储字符串
B)	操作string类型必须包含头文件string
C)	string类型可以使用cout进行输出
D)	string类型就是C语言的字符串类型
△D△
在程序中，要求实现类似功能多个函数，选用（）。
A) 内联函数
B) 重载函数
C) 递归调用
D) 嵌套调用
△B△
下列语句中，将函数int sum(int x, int y)正确重载的是（）。
A) float sum(int x, int y);
B) int sum(int a, int b);
C) float sum(float x, float y);
D) double sum(int y, int x);
△C△
关于函数重载以下描述正确的是（）。
A) 函数名相同，参数的类型和个数也相同，返回值的类型不同
B) 函数名不同，参数的类型和个数都相同
C) 函数重载是静态多态性的一种机制
D) 函数重载是动态多态性的一种机制
△C△
对于函数重载，以下说法错误的是（）。
A)	函数重载允许多个函数重名
B)	重载的多个函数可以只具有不同数目的参数
C)	重载的多个函数可以只具有不同类型的参数
D)	重载的多个函数可以只具有不同类型的返回值
△D△
要求一个函数实现一种不太复杂的功能，并要求加快执行速度，应选用（）。
A) 内联函数
B) 重载函数
C) 递归调用
D) 嵌套调用
△A△
内联函数使用关键字（）定义。
A)	inline
B) online
C) static
D) outline
△A△
假定AA为一个类，a为该类的私有数据成员，GetValue( )为该类公有成员函数，它返回a的值，x为该类的一个对象，则访问x中的数据成员a的格式为（）。
A) x->GetValue()
B) x.GetValue( )
C) x.a
D) x.a()
△B△
下面关于类概念的描述中错误的是（）。
A) 类是抽象数据类型的实现
B) 类是具有共同行为的若干对象的统一描述体
C) 类是创建对象的样板
D) 类就是C语言中的结构体类型
△D△
设AA为一个类，int a();为该类的成员函数，若该函数在类定义外定义，则函数头为（）。
A) int AA::a()
B) int AA:a()
C) AA::a()
D) AA:: int a( )
△A△
下列关于类和对象的说法中，错误的是（）。
A) 类是一个模板，用来创建对象
B) 对象是类的实例
C) 对象是一个蓝图，用来创建类
D) 类把数据和函数封装在一起
△C△
类的实例化是指（）。
A) 定义类
B) 创建类的对象
C) 指明具体类
D) 调用类的成员
△B△
可以在主函数中用a.x的形式访问类成员x，其中x一定是（）。
A) 静态成员
B) 公有成员
C) 保护成员
D) 私有成员
△B△
以下哪种不属于类的成员访问修饰符（）。
A) public
B) protect
C) protected
D) private
△B△
关于成员函数特征的下述描述中，（）是错误的。
A)	成员函数一定是内联函数
B)	成员函数可以重载
C)	成员函数可以设置参数的默认值
D)	成员函数可以是静态的
△A△
已知ST类，则当程序执行到语句：ST  a[4];时，调用了（）次构造函数。
A) 4
B) 3
C) 2
D) 1
△A△
下列关于构造函数说法错误的是（）。
A) 构造函数必须与类同名
B) 构造函数可以省略不写
C) 构造函数必须有返回值
D) 在构造函数中可以重载
△C△
下列关于构造函数说法正确的是（）。
A) 构造函数必须与类同名
B) 构造函数必须重载
C) 构造函数必须与对象同名
D) 构造函数可以有返回值
△A△
构造函数的函数名是（）。
A) 对象名
B)对象的成员名
C) 类名
D) 对象的指针
△C△
下列函数可以作为类BBB的构造函数的是（）。
A）int BBB()
B) BBB::BBB()
C) BBB::~BBB()
D)void BBB::BBB()
△B△
类的析构函数的作用是（）。
A) 成员函数的初始化
B) 类的初始化
C) 对象的初始化
D) 删除类创建的对象
△D△
以下说法中正确的是（）。
A)	析构函数的函数名与构造函数的函数名相同
B)	析构函数的返回值类型为void型
C)	一个类只能定义一个析构函数
D)	一个类可以定义多个析构函数
△C△
在一个类的对象被销毁时，系统会自动调用的函数是（）。
A) 公共成员函数
B) 私有成员函数
C) 构造函数
D)析构函数
△D△
下列函数可以作为类AAA的析构函数的是（）。
A） int AAA()
B) AAA::AAA()
C) AAA::~AAA()
D)int AAA:AAA()
△C△
下列关于this指针的说法正确的是（）。
A)	this指针是指向类的数据成员的指针
B)	成员函数中的this指针是指向调用该函数的对象
C)	this指针是指向虚函数的指针
D)	this指针是指向类的函数成员的指针
△B△
类stu中的int类型静态成员number，在类外正确的初始化形式为（）。
A) int number = 0;
B) static int number = 0;
C) static int stu::number = 0;
D) int stu::number = 0;
△D△
关于静态成员变量，以下叙述错误的是（）。
A)	静态成员变量使用static声明
B)	静态成员变量需要在类外定义
C)	每个类对象都拥有一个静态成员变量副本
D)	静态成员变量被类所有对象共享
△C△
对于动态分配内存空间描述正确的是（）。
A)	使用new运算符分配的内存空间的长度必须是常量
B)	delete运算符可以释放动态的存储空间和静态的存储空间
C)	由new分配的内存空间是不连续的
D)	delete运算符只能释放由new分配的动态存储空间
△D△
使指针p指向一个具有5个连续的float型存储单元，下列定义正确的是（）。
A) float *p=5*(new float);
B) float *p=new float[5];
C) float *p=new 5*sizeof(float);
D) float *p=new float(5);
△B△
从原有类定义新类可以实现的是因为（）。
A) 信息隐藏
B) 数据封装
C) 继承机制
D) 数据抽象
△C△
下列对派生类的描述中错误的是（）。
A)	一个派生类可以作为另一个派生类的基类
B)	派生类至少有一个基类
C)	派生类的成员除了自己的成员外，还包含了它的基类的成员
D)	派生类中继承的基类成员的访问权限在派生类中保持不变
△D△
派生类的对象p用p.a的形式访问其基类的数据成员a，其中a是（）。
A) 私有继承的公有成员
B) 公有继承的公有成员
C) 私有继承的保护成员
D) 公有继承的私有成员
△B△
以下关于继承的描述正确的是（）。
A) 派生类中不可以添加基类中没有的新的数据成员
B) 派生类创建对象时总是先调用基类的构造函数
C) 派生类的析构函数总是在基类的析构函数被调用之后调用
D) 派生类继承基类的构造函数
△B△
下面对派生类的描述中，错误的是（）。
A)	派生类可以继承基类的构造函数
B)	派生类可以有多个基类
C)	派生类的成员除了它自己的成员外，还包含了它的基类的成员
D)	一个派生类可以作为另外一个派生类的基类
△A△
当保护继承时，基类的（）在派生类中成为保护成员。
A) 任何成员
B) 公有成员和保护成员
C) 公有成员和私有成员
D) 私有成员
△B△
通过运算符重载，可以改变运算符原有的（）。
A) 操作数类型
B) 操作数个数
C) 优先级
D)结合性
△A△
C++中，为了让运算符支持自定义类，使用（）来实现。
A）	函数重载
B）模板
C） 运算符重载
D）虚函数
△C△
在下列运算符中,不能重载的是（）。
A) ++
B) =
C) ==
D） ：：
△D△
在成员函数中进行双目运算符重载时，其参数表中应带有（）个参数。
A） 0
B） 1
C） 2
D） 3
△B△
在成员函数中进行单目运算符重载时，其参数表中应带有（）个参数。
A） 0
B） 1
C） 2
D） 3
△A△
如果表达式a*b中的"*"是作为成员函数重载的运算符，若采用运算符函数调用格式，则可表示为（）。
A） a.operator*(b)
B） b.operator*(a)
C） operator*(a,b)
D） operator(a*b)
△A△
如果表达式a+b中的"+"是作为成员函数重载的运算符，若采用运算符函数调用格式，则可表示为（）。
A） a.operator+(b)
B） b.operator+(a)
C） operator+(a,b)
D） operator(a+b)
△A△
如果表达式a-b中的"-"是作为非成员函数重载的运算符，若采用运算符函数调用格式，则可表示为（）。
A） a.operator-(b)
B） b.operator-(a)
C） operator-(a,b)
D） operator(a-b)
△C△
如果表达式a++中的"++"是作为非成员函数重载的运算符，若采用运算符函数调用格式，则可表示为（）。
A) a.operator++()
B) operator++(a)
C) operator++(a,1)
D) operator++(1,a)
△C△
通常的拷贝构造函数的参数是（）。
A) 对象名
B)对象的成员名
C) 对象的引用
D) 对象的指针
△C△
关于虚函数的描述中错误的是（）。
A)	派生类的虚函数与基类的虚函数具有不同的参数个数和类型
B)	C++用关键字virtual来声明虚函数
C)	在基类中说明了虚函数后，派生类中对应的函数可不必说明为虚函数
D)	C++使用虚函数实现多态性
△A△
在C++中，用于实现动态多态性的是（）。
A) 内联函数
B) 虚函数
C) 构造函数
D) 重载函数
△B△
设置虚基类的目的是（）。
A) 简化程序
B) 消除二义性
C) 提高运行效率
D) 减少目标代码
△B△
以下基类中的成员函数，哪个表示纯虚函数（）。
A）virtual void vf(int)；
B） void vf(int)=0；
C）virtual void vf(int)=0；
D） virtual void vf(int){ }
△C△
当一个类的某个函数被说明为virtual时，该函数在该类的所有派生类中（）。
A) 都是虚函数
B) 只有被重载时才是虚函数
C) 只有被重新说明为virtual时才是虚函数
D) 都不是虚函数
△A△
