 下面函数增长率最高的是(     )。
   A. 2的100次方  B. (3/2)的n次方  C. n的50次方  D. log10n
△B△
 下面函数增长率最低的是(     )。
   A. n2  B. log2(log2n)  C. nlog2n  D. (log2n)
△B△
 下面函数增长率最低的是(     )。
   A. n的log2n次方 B. (4/3)ⁿ  C. nⁿ  D. n!
△A△
 下面函数增长率最高的是(     )。
 A. ∑（从 i=1 到 n）i²/n  B. ∑（从 i=1 到 n）n/i  C. ∑（从 i=1 到 n）i  D.log(n!)
△C△
 算法分析中，记号O表示（    ）。
   A. 渐进下界  B. 渐进上界  C. 非紧上界  D. 紧渐近界
△B△
 算法分析中，记号Ω表示（     ）。
   A. 渐进下界  B. 渐进上界  C. 非紧上界  D. 紧渐近界
△A△
 算法分析中，记号Θ表示（     ）。
   A. 渐进下界  B. 渐进上界  C. 紧渐近界  D. 非紧下界
△C△
 发生非法操作时，算法能够做出适当处理的特性称为(     )。
   A. 正确性  B. 健壮性  C. 可读性  D. 可移植性
△B△
 下面说法错误的是(     )。
   A. 算法原地工作的含义是指所需的额外辅助工作空间为常量。
   B. 在相同的规模n下，算法复杂度O(n)的算法总是优于复杂度O(2n)的算法。
   C. 所谓的时间复杂度，是指最坏的情况下，估算算法执行时间的一个上界。
   D. 同一算法，实现语言的级别越高，执行效率就越低。
△B△
 递归算法和迭代算法相比较具有以下特点（    ）。
   A. 代码复杂度高  B. 执行效率高  C. 占用内存高  D. 代码可读性高
△D△
 Strassen矩阵乘法采用的是(     )。
   A. 贪心法  B. 动态规划法  C. 分治策略  D. 回溯法
△C△
 以下不可以使用分治法求解的是(     )。
   A. 棋盘覆盖问题  B. 选择问题   C. 归并排序     D. 0/1背包问题
△D△
 实现循环赛日程表利用的算法是(     )。
   A. 分治策略  B. 动态规划法  C. 贪心法  D. 回溯法
△A△
 用分治法计算Fibonacci数列第n项的算法复杂度为(     )。
   A. O(1)     B. O(logn)	    C. O(n)       D. O(nlogn) 
△B△
 利用(     )实现幂乘计算可使时间复杂度能达到O(logn)。
   A. 回溯法     B. 动态规划法    C. 贪心法       D. 分治法  
△D△
 实现合并排序利用的算法是(     )。
   A. 分治策略     B. 动态规划法     C. 贪心法     D. 回溯法 
△A△
 二分搜索算法的基本思想是将n个元素分成个数大致相同的两半，取a[n/2]与 x 进行比较：如果(     )，则只要在数组a的左半部继续搜索x。
   A. x≥a[n/2]   B. x＞a[n/2]  C. x＜a[n/2]  D. x≤a[n/2] 
△C△
 实现快速排序算法如下,缺少的语句是(     )。
void quickSort(int a[], int p,int r) {
 	if(p<r) { int q=partition(p,r);  (     ) ;  quickSort(q+1,r); } 
} 
   A. quickSort(p,q-1)  B. quickSort(p-1,q-1)  C. quickSort(p-1,q)  D. quickSort(p,q)
△A△
 应用分治法的两个前提是(     )。 
   A. 问题的复杂性和解的可归并性  B. 问题的可分性和解的存在性
   C. 问题的可分性和解的可归并性  D. 问题的可分性和解的复杂性 
△C△
 使用分治法求解不需要满足的条件是(     )。 
   A. 原问题和子问题使用相同的方法	   B. 子问题不能够重复
   C. 子问题的解可以合并   D. 子问题必须是一样的  
△D△
 动态规划算法与分治算法在分解子问题方面不同点是(     )。
   A. 子问题不互相独立  B. 子问题互相独立  C. 子问题互相交叉  D. 子问题无要求
△A△
 区分用动态规划还是贪心算法求解问题所依据的关键特征是(     )。
   A. 重叠子问题  B. 最优子结构性质  C. 贪心选择性质  D. 定义最优解
△C△
 实现最大子段和利用的算法是（     ）。
   A. 分治策略  B. 动态规划法  C. 贪心法  D. 回溯法
△B△
 下列算法中不能解决0/1背包问题的是(     )。
   A. 贪心法  B. 动态规划  C. 回溯法  D. 分支限界法
△A△
 下列各项中，属于动态规划算法基本要素的是(     )。
   A. 定义最优解  B. 构造最优解  C. 算出最优解  D. 子问题重叠性质
△D△
 下列算法中通常以自底向上的方式求解最优解的是(     )。
   A. 分治法  B. 动态规划法  C. 递归法  D. 回溯法
△B△
 以下问题求解中不能使用动态规划算法的是(     )。
   A. 始终点最短路径  B. 投资问题  C. 汉内塔问题  D. 找零钱问题
△C△
 下列不是动态规划算法基本步骤的是(     )。
   A. 找出最优解的性质   B. 构造最优解  C. 算出最优解   D. 定义最优解
△A△
 适用动态规划的问题必须满足(     )。
   A. 最优化原理  B. 无前效性  C. 最优化原理和后效性  D. 最优化原理和无后效性
△D△
 完全背包问题（有n种物品，每种物品的重量和价值分别为wi、vi，每种物品可以放多个，背包限重m，求最大价值装载）的最优算法复杂度是(     )，采用的算法是(     )。
   A. O(nm²)  B. O(nm)  C. O(mn²)  D. O(n³)
   A. 分治法  B. 回溯法  C. 贪心法  D. 动态规划
   （两个答案字母连起来写）
△BD△
 下列哪些问题不能用贪心法求解(     )？
   A. 霍夫曼编码问题  B. 单源最短路径问题  C. 0-1背包问题  D. 最小生成树问题
△C△
 下面是贪心算法基本要素的是(     )。
   A. 重叠子问题  B. 构造最优解  C. 贪心选择性质  D. 定义最优解
△C△
 贪心算法与动态规划算法的主要区别是(     )。
   A. 最优子结构  B. 贪心选择性质  C. 构造最优解  D. 定义最优解
△B△
 一个问题可用动态规划算法或贪心算法求解的关键特征是问题的(     )。
   A. 重叠子问题    B. 最优子结构性质    C. 贪心选择性质   D. 定义最优解
△B△
 下列算法中通常以自顶向下的方式求解最优解的是(     )。
   A. 备忘录法  B. 动态规划法  C. 贪心法  D. 回溯法
△C△
 背包问题的贪心算法所需的计算时间为(     )。
   A. O(n²)     B. O(nlogn)   C. O(2ⁿ)  D. O(n) 
△B△
 最小延迟调度问题的适合算法是(     )。
   A. 备忘录法  B. 动态规划法  C. 贪心法  D. 回溯法
△C△
 会议室最多相容活动安排贪心法的算法复杂度是(     )。
   A. O(n²)     B. O(2ⁿ)   C. O(nlogn)  D. O(n)
△C△
 给定一组不同长度的排好序文件构成的集合,使用二分归并将这些文件归并成一个有序的文件.采用(     )可以得到最小的比较次数。
   A. 分治法     B. 动态规划法   C. 贪心法  D. 回溯法
△C△
 现有4件物品，其重量wi和价值vi分别为{30,20,70,10}、{100,120,10,50}，背包的最大负重是100，贪心法求最大价值装载的次序是(     )。
   A. {2,4,1,3}     B. {3,1,2,4}   C. {2,1,4,3}  D. {1,2,3,4}
△A△
 回溯法求解TSP问题时生成的解空间树叫做(     )。
   A. 子集树  B. 排列树  C. 深度优先生成树  D. 广度优先生成树
△B△
 下列算法中通常以深度优先方式系统搜索问题解的是(     )。
   A. 备忘录法  B. 动态规划法  C. 贪心法  D. 回溯法
△D△
 回溯法的效率不依赖于下列哪些因素(     )。
   A. 满足显式约束值的个数  B. 计算约束函数的时间
   C. 计算限界函数的时间  D. 确定解空间的时间
△D△
 下面哪种函数是回溯法中为避免无效搜索采取的策略(     )。
   A. 递归函数  B. 剪枝函数  C. 随机数函数  D. 搜索函数
△B△
 回溯法遍历状态空间搜索树的顺序是(     )。
   A. 中序遍历  B. 广度优先遍历  C. 深度优先遍历  D. 层次优先遍历
△C△
 0-1背包问题的回溯算法所需的计算时间为(     )。
   A. O(n2ⁿ)     B. O(nlogn)     C. O(2ⁿ)     D. O(n) 
△C△
 货郎问题TSP用回溯法求解的算法复杂度为(     )。
   A. O(n2ⁿ)     B. O(2ⁿ )     C. O(n!)     D. O((n-1)!) 
△D△
 装载问题中n个集装箱要装上2个轮船，回溯法的算法复杂度是(     )。
   A. O(n2ⁿ)     B. O(2ⁿ )     C. O(n!)     D. O((n-1)!) 
△B△
 n个顶点m种颜色的着色问题，回溯法的算法时间复杂度是(     )。
   A. O(nmⁿ)  B. O(mⁿn)  C. O(nmᵐ)  D. O(mnᵐ)
△A△
 会议室最多相容活动安排回溯法的算法复杂度是(     )。
   A. O(n²)     B. O(logn)   C. O(n)  D. O(n!)
△D△
 最坏情况下的时间复杂性函数用下列形式表示（     ）。
   A. T(n)  B. W(n)  C. A(n)  D. F(n)
△B△
 求两个n×n矩阵乘积算法类的下界是（     ）。
   A. n²  B. n!  C. n³  D. n².8075
△A△
 下列说法不正确的是(     )。
   A. f(n)=n²，f(n)是多项式时间复杂度算法
   B. f(n)=nlogn，f(n)是多项式时间复杂度算法
   C. f(n)=logn，f(n)是多项式时间复杂度算法
   D. f(n)=logn，g(n)=n²，f(n)和g(n)是多项式相关的
△D△
 下面关于NP问题说法正确的是(     )。
   A. P类问题包含在NP类问题中  B. NP问题都是不可能解决的问题
   C. NP完全问题是P类问题的子集  D. NP类问题包含在P类问题中
△A△
 以比较运算作为基本运算的找最大问题，最优算法是(     )次比较。
   A. n-1  B. n  C. n+1  D. n/2
△A△
 以下算法中需要辅助存储空间最多的是(     )。
   A. 快速排序  B. 冒泡排序  C. 归并排序  D. 堆排序
△C△
 以下算法中需要时间复杂度和空间复杂度均达到最优的算法是(     )。
   A. 快速排序  B. 冒泡排序  C. 归并排序  D. 堆排序
△D△
 冒泡排序的原始输入(5, 3, 2, 6, 9, 1, 4, 8, 7)，则第一轮排序之后结果为(     )。
   A. (1, 2, 3, 4, 5, 6, 7, 8, 9)  B. (9, 8, 7, 6, 5, 4, 3, 2, 1)
   C. (3, 2, 5, 6, 1, 4, 8, 7, 9)  D. (5, 3, 2, 6, 1, 4, 8, 7, 9)
△C△
 下面关于NP问题说法正确的是(     )。
   A. NP问题都是不可能解决的问题  B. P类问题包含在NP类问题中
   C. NP完全问题是P类问题的子集  D. NP类问题包含在P类问题中
△B△
 下列说法不正确的是(     )。
   A. P类问题是可解性问题，NP类问题是难解性问题
   B. NP类问题不一定是难解性问题，因为P类问题也一定是NP类问题
   C. NP类问题不确定是否是P类问题，但NPC类问题一定是难解性问题
   D. 其他三个选项的说法有不正确的
△A△