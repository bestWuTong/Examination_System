用主定理法可以解决所有的递归问题的复杂度计算。
△F△
算法的时间复杂度和空间复杂度总是相同的，因此每个算法只要分析时间复杂度即可。
△F△
递归算法与迭代算法比较，具有编程简单，结构清晰，运行速度快的特点。
△F△
迭代法、递推法、尝试法、积分法、主定理法和递归树是算法分析的主要分析方法。
△T△
算法可以没有输入但是必须有输出。
△T△
算法分析中的迭代法包括：直接迭代、换元迭代、消元迭代和循环迭代分析法。
△F△
算法的表达方式可以是自然语言、伪代码、程序框图及程序设计语言。
△T△
解决某一问题的算法复杂度最优的算法是唯一的。
△F△
健壮的算法不会因为非法的输入数据而出现莫名其妙的状态。
△T△
算法的优劣与描述算法的语言无关，而与所用的计算机的性能有关。
△F△
二分搜索方法在最坏的情况下用O(log n)时间完成搜索任务。
△T△
分治法的基本思想是将一个规模较大的问题分解成若干个规模较小的子问题，这些子问题之间并不一定相互独立。
△F△
能否利用分治法完全取决于问题是否具有如下特征：利用该问题分解出的子问题的解可以合并为该问题的解。
△F△
反复应用分治手段能使子问题与原问题类型一致而其规模却不断缩小 。
△T△
采用分治策略的芯片测试问题的算法复杂度可以达到O(n)。
△T△
Strassen算法的重要意义在于他证明了矩阵相乘问题的算法复杂度O(n³)不是最优解。
△T△
分治法解决平面点对问题的算法复杂度为O(nlog²n)
△F△
原始数据27,99,0,8,13,64,86,16,7,10,88,25,90，以第一个数做为划分标准做快速排序，第一轮交换之后数据变为16,25,0,8,13,10,7,27,86,64,88,99,90。
△T△
快速排序算法的平均复杂度是基于比较排序法中最优的排序算法。
△T△
用分治法求解Fibonacci数列第n项值时，算法时间复杂度为O(logn)。
△T△
动态规划算法的要求是由原问题分解出的各个子问题的解必须是最优解。
△T△
矩阵序列相乘问题不适合动态规划算法。
△F△
m元钱,n个项目的投资问题,可以通过动态规划算法实现。
△T△
完全背包问题中，求背包最大价值的不可以使用动态规划法。
△F△
动态规划的实质是分治思想和解决冗余，因此，动态规划是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免计算重复的子问题，以解决最优化问题的算法策略。
△T△
最优子结构性质是指原问题的最优解包含其子问题的最优解。
△T△
动态规划算法求解问题时,分解出来的子问题相互独立。
△F△
动态规划算法最基本要素是最优子结构。
△T△
动态规划法与分治法和贪心法类似，它们都是将问题实例归纳为更小的、相似的子问题，并通过求解子问题产生一个全局最优解。
△T△
最长公共子序列LCS问题适合于回溯法。
△F△
贪心法可以进行贪心选择的关键在于该问题的最优子结构性质。
△F△
用贪婪算法解决零钱兑换问题时,总能找到问题的最优解。
△F△
贪心法必需满足贪心选择性质。
△T△
完全背包问题和0-1背包问题可以用贪心法求解。
△F△
客户服务的最小延迟的活动安排问题适合于贪心法解决。
△T△
求解最优前缀码的霍夫曼编码适合于贪心法解决。
△T△
最优装载问题是0-1背包问题的特例，所以最优装载问题不适合贪心法。
△F△
适合于贪心法解决的问题一般都适合于动态规划法。
△T△
贪心法属于动态规划法的一种特例。
△F△
对于使用最小数目硬币找零钱的问题，贪心法总能给出最优解。
△F△
贪心法常以当前情况为基础作最优选择，而不考虑各种可能的整体情况，所以贪心法不要回溯。
△T△
回溯法中常见的两类典型的解空间树是子集树和排列树。
△T△
回溯法中限界函数的目的是剪去得不到最优解的子树。
△T△
用回溯法解题一个显著特征是在搜索过程中动态产生问题的解空间。
△T△
可由回溯法求下列不等式的整数解5x₁+4x₂-x₃ ≤ 10, 1 ≤ xi ≤ 3, i=1,2,3。
△F△
对于同时适用贪心法和回溯法解决的问题，可以任选两种实现方式的一种。
△F△
回溯法适合求解n项会议安排问题，要求时间不相冲突时占用会场数最小。
△T△
求解有n个顶点的最大团问题，回溯算法复杂度是O(2ⁿ)。
△F△
回溯法求解圆排列问题(给定n个圆的半径序列，将他们放到矩形框中，各圆与矩形边相切，求具有最小排列长度的圆排列次序)算法复杂度为O(n2ⁿ)。
△T△
回溯法可在O(mn!)时间解决连续邮资问题(设有n种不同面值(整数)的邮票，每个信封最多贴m张邮票，试给出邮票面值的最佳设计，使得增量为1的连续邮资区间最大)。
△F△
决策树(或判定树)是一个二叉树，具有二叉树的性质。
△F△
在二叉树的 t 层至多 2ᵗ 个结点（根为 0 层）
△T△
深度为 d 的二叉树至多 2ᵈ⁺¹-1 个结点.
△T△
n个结点的二叉树的深度至少为⌊ log n ⌋ 。
△T△
设t为二叉树的树叶个数，d为树深，如果树的每个内结点都有2个儿子，则 t ≤ 2ᵈ 。
△T△
n 个结点的堆恰好有 片树叶
△T△
归并排序算法是原地排序的算法。
△F△
按相同关键字在排序前后的位置不同分为稳定排序和不稳定排序，堆排序是稳定排序算法。
△F△
P类问题是存在多项式时间算法的问题。
△T△
NP类问题是不存在多项式时间算法的问题。
△F△